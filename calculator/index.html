<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kode+Mono:wght@400..700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="../img/calculator.png">
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="box-style">
        <div class="result-box">
            <textarea id="display" row="1" readonly placeholder="0"></textarea>
        </div>
        <div class="btns-box">
            <button data-value="clear" class="box-style btn-sm clear">C</button>
            <button id="parenthesis" class="box-style btn-sm">()</button>
            <button class="box-style btn-sm history">
                <img src="../img/history.png">
            </button>
            <button class="box-style btn-sm delete">
                <img src="../img/delete.png">
            </button>

            <button data-value="+" class="box-style btn-sm font-h operator">+</button>

            <button data-value="1" class="box-style btn-sm">1</button>
            <button data-value="2" class="box-style btn-sm">2</button>
            <button data-value="3" class="box-style btn-sm">3</button>

            <button data-value="-" class="box-style btn-sm font-h operator">-</button>

            <button data-value="4" class="box-style btn-sm">4</button>
            <button data-value="5" class="box-style btn-sm">5</button>
            <button data-value="6" class="box-style btn-sm">6</button>

            <!-- x multiply -->
            <button data-value="*" class="box-style btn-sm font-h multiply operator">x</button>

            <button data-value="7" class="box-style btn-sm">7</button>
            <button data-value="8" class="box-style btn-sm">8</button>
            <button data-value="9" class="box-style btn-sm">9</button>

            <button data-value="÷" class="box-style btn-sm divide operator">÷</button>

            <button data-value="0" class="box-style btn-sm">0</button>
            <button data-value="." class="box-style btn-sm">.</button>
            <button data-value="result" class="box-style btn-sm lg-txt result">=</button>

            <div class="history-box">
                <div>
                    <!-- <div>
                        <p class="equ">234+789-849*(23+9)</p>
                        <p class="equ-ans">=345</p>
                    </div> -->
                </div>
                <p class="empty-history">Your history is empty. Start calculating!</p>
            </div>
        </div>
    </div>

    <div class="error">
        <div class="error-box">
            <div class="close btn-sm box-style"><span>+</span></div>
            <div class="message"></div>
        </div>
    </div>


    <span id="info">i</span>
    <div class="details">
        <div>
            <h2><img src="../img/gears.png" alt="calculation"> Calculation Engine</h2>
            <ol>
                <li><b>Shunting Yard Algorithm:</b> Ensures accurate order of operations using operator
                    precedence and associativity.
                </li>
                <li><b>Regex-Powered Parsing:</b> Used heavily for expression splitting, validation, and clean
                    number formatting.
                </li>
                <li><b>Decimal Control:</b>
                    <ul>
                        <li>Only one decimal point allowed per number.</li>
                        <li>Maximum 10 digits allowed after a decimal point.</li>
                    </ul>
                </li>
                <li><b>15-digit Limit Enforcement:</b> Restricts each number to a total of 15 digits (before +
                    after decimal).
                </li>
                <li><b>Division by Zero Handling:</b> Prevents invalid calculations and returns user-friendly
                    error messages.
                </li>
                <li><b>Floating Point Error Correction:</b>
                    Minimizes rounding errors caused by JavaScript floating point math for most real-world calculations.
                </li>
                <li><b>Auto-Balanced Parentheses:</b> Automatically closes unmatched opening brackets for a valid
                    expression.
                </li>
            </ol>

            <h2><img src="../img/contactform.png" alt="calculation"> Input Handling</h2>
            <ol>
                <li><b>Smart Operator Replacement:</b> Prevents invalid operator sequences like 4+* by replacing
                    the previous one (4*).
                </li>
                <li><b>Validation after "(":</b> Only allows + or - immediately after an opening parenthesis to
                    ensure valid math expressions.
                </li>
                <li><b>Backspace & Delete Logic:</b> Works seamlessly to modify the input without breaking the
                    formula.
                </li>
                <li><b>Prevent Input Focus Trigger:</b> Avoids unwanted evaluations via Enter key when a button
                    is focused.
                </li>
                <li><b>Division by Zero Handling:</b> Prevents invalid calculations and returns user-friendly
                    error messages.
                </li>
                <li><b>Auto-Balanced Parentheses:</b> Automatically closes unmatched opening brackets for a valid
                    expression.
                </li>
            </ol>

            <h2><img src="../img/form.png" alt="ui/ux"> UI/UX Enhancements</h2>
            <ol>
                <li><b>Dynamic Font Resizing:</b> Font size automatically adjusts based on input length to fit in
                    the display area.
                </li>
                <li><b>Scrollable Display:</b> Display automatically scrolls to show newly typed values. Users can
                    scroll within the input area to view full-length expressions.
                </li>
                <li><b>Clean Error Messaging:</b> Friendly and visually consistent error alerts for any invalid
                    input.
                </li>
                <li><b>Calculation History Panel:</b> Displays previous expressions and results for
                    quick reference.
                </li>
                <li><b>Mobile-Friendly Design:</b> Optimized interactions and input handling for smaller screen
                    devices.
                </li>
            </ol>

            <h3 style="text-align: center;"><i>"Built with ❤️, patience, and an obsession for perfection!"</i></h3>
        </div>
    </div>

    <script>

        const input = document.getElementById("display");
        const btnCon = document.querySelector(".btns-box");
        const clearBtn = document.querySelector(".clear");
        const resultBtn = document.querySelector(".result");
        const deleteBtn = document.querySelector(".delete");
        const ptheBtn = document.querySelector("#parenthesis");
        const historyBtn = document.querySelector(".history");
        const historyCon = document.querySelector(".history-box");
        const historyChild = document.querySelector(".history-box>div");
        const infoBtn = document.getElementById("info");
        let openParenthesis = 0;
        const history = [];

        // parenthesis functionality 
        ptheBtn.addEventListener("click", function (e) {
            this.blur();
            const value = input.value;
            const lastChar = value.slice(-1);

            // Count open and close parentheses to determine balance
            const openCount = (value.match(/\(/g) || []).length;
            const closeCount = (value.match(/\)/g) || []).length;
            // Close parentheses if open > close
            if (openCount > closeCount && /[0-9.)]/.test(lastChar)) {
                input.value += ")";
            }
            // after number, decimal or closing parenthesis → insert multiplication and open
            else if (/^\d+(\.)?$/.test(value) || /^\d+(\.\d+)?$/.test(value) || /[0-9).]/.test(lastChar)) {
                input.value += "*(";
            }
            // If empty or after operator → insert open parenthesis
            else if (
                value === "" ||
                openCount === closeCount ||
                lastChar === "(" ||
                /[+\-*/(]/.test(lastChar)
            ) {
                input.value += "(";
            }
        });

        // calculator's buttons click event
        btnCon.addEventListener("click", function (e) {
            let currentVal = e.target.dataset.value;
            adjustFontSize(); // inc/dec font-size if text is longer
            setTimeout(() => {
                input.scrollTop = input.scrollHeight - 1; // to make the user see new values on the new line
            }, 0);

            if (
                currentVal !== undefined &&
                currentVal !== null &&
                currentVal != "" &&
                currentVal != "clear" &&
                currentVal != "result"
            ) {
                let prevVal = input.value;
                let newVal = prevVal + currentVal;

                const lastNumber = newVal.split(/[\+\-\*\/÷\(\)]/).pop(); // Get the most recent number
                const digitCount = lastNumber.replace(/[^0-9]/g, "");

                if (digitCount.length > 15) {
                    showError(`<b>Invalid input:</b><br>Can't enter more than 15 digits`);
                    return;
                }
                /*
                    preventing (1)2 this we convert it to (1)*2
                    if last char is number then replace it with *num 
                    if last char is . then replace it with *0. 
                */
                if (/\d/.test(newVal[newVal.length - 1]) || /\./.test(newVal[newVal.length - 1])) {
                    let lastVal = newVal[newVal.length - 1];
                    let last2nd = newVal[newVal.length - 2];
                    if (last2nd === ")" && /\d/.test(lastVal)) {
                        let newString = newVal.slice(0, -1);
                        newVal = `${newString}*${lastVal}`;
                    }
                    if (last2nd === ")" && /\./.test(lastVal)) {
                        let newString = newVal.slice(0, -1);
                        newVal = `${newString}*0${lastVal}`;
                    }
                }

                // when user tries to do this 5÷02 we replace 02 with 2 like this 5÷2

                // Extracts the number right after the division symbol.
                // Trims leading zeros unless the number is like 0.2(i.e., a valid decimal).
                // Checks if the value is exactly zero, not just starts with 0.

                // if (/\d+(\.\d+)?÷0+/.test(newVal)) {
                //     let afterDiv = newVal.split("÷");
                //     let zeroPart = afterDiv[afterDiv.length-1];
                //     if(/^0+[^\d\.]?/.test(zeroPart) && zeroPart.length > 1){

                //         console.log("i am here");
                //     }
                // }
                // if(/\d+(\.\d+)?÷0{1}/.test(newVal)){
                //     let lastChr = newVal[newVal.length -1];
                //     let newString = newVal.slice(0, -2);
                //     console.log(newString, lastChr);
                //     if(lastChr != "0"){
                //         newVal = `${newString}${lastChr}`;
                //     }
                //     if(lastChr == "."){
                //         newVal = `${newString}0${lastChr}`;
                //     }
                // }

                // prevent starting with an operator
                if (prevVal == "" && /[+\-*/÷]/.test(currentVal)) {
                    return showError("Invalid input");
                }

                // prevent consecutive operators (if 4 + * replacing the + with * and so on)
                if (/[+\-*/÷]/.test(prevVal[prevVal.length - 1]) && /[+\-/*÷]/.test(currentVal)) {
                    let withoutLastChar = prevVal.slice(0, -1);
                    newVal = withoutLastChar + currentVal;
                }

                // preventing double decimal (..) after a number
                if (/[.]/.test(currentVal)) {
                    if (prevVal[prevVal.length - 1] == ".") {
                        let withoutLastChar = prevVal.slice(0, -1);
                        newVal = withoutLastChar + currentVal;
                    }
                }

                // prevent having muliple decimal in one number by removing the 2nd . 
                if (/\d+\.\d{1,10}\.$/g.test(newVal)) {
                    newVal = newVal.slice(0, -1);
                }

                // preventing more than 10 digits after decimal
                if (/\d+(\.\d{11,})/.test(newVal)) {
                    showError(`<b>Invalid input:</b><br>Can't enter more than 10 digits after decimal points.`);
                    return;
                }

                // putting 0. before . in case there is not digit before . decimal
                // also if (2) and user clicks on . btn then the string should convert to (2)*0.
                if (/^\.|[+\-*/÷()]\.$/.test(newVal)) {
                    if (prevVal != "") {
                        newVal = prevVal + "0.";
                    } else {
                        newVal = "0.";
                    }
                }

                if (/\([\*|\/|÷]/.test(newVal)) {
                    showError(`<b>Invalid operator:</b><br>Use only + or - operator after "("`);
                    return;
                }

                input.value = newVal;
            }
            if (e.target != resultBtn) {
                e.target.blur();
            }
        });

        // keyboard accessible calculator
        const keyMap = {
            "1": "1",
            "2": "2",
            "3": "3",
            "4": "4",
            "5": "5",
            "6": "6",
            "7": "7",
            "8": "8",
            "9": "9",
            "0": "0",
            "+": "+",
            "-": "-",
            "*": "*",
            "/": "÷",
            ".": ".",
            "Escape": "clear",
            "Delete": "clear",
            "Enter": "result"
        }
        window.addEventListener("keydown", function (e) {
            const value = keyMap[e.key];
            if (e.key === "Backspace") {
                deleteBtn.click();
                deleteBtn.classList.add("pressed");
                setTimeout(() => {
                    deleteBtn.classList.remove("pressed");
                }, 200);
            }
            if (e.key === "(" || e.key === ")") {
                ptheBtn.click();
                ptheBtn.classList.add("pressed");
                setTimeout(() => {
                    ptheBtn.classList.remove("pressed");
                }, 200);
            }
            if (value) {
                const btn = document.querySelector(`button[data-value='${value}']`);
                if (btn) {
                    btn.click();
                    btn.classList.add("pressed");
                    setTimeout(() => {
                        btn.classList.remove("pressed");
                    }, 200);
                };
            }
        });

        // clearing (emptying) input
        clearBtn.addEventListener("click", function (e) {
            input.value = "";
            this.blur();
        });

        // deleting 1 character at a time form back
        deleteBtn.addEventListener("click", function (e) {
            input.value = input.value.slice(0, -1);
            this.blur();
        });

        // call for evaluation (clicking eqaul button for calculation)
        resultBtn.addEventListener("click", function () {
            let eval = input.value.replace(/÷/g, "/");

            // counting the digits after decimal so result can also have same number of digits after decimal
            // const maxDecimalDigits = Math.max(
            //     0,
            //     ...Array.from(eval.matchAll(/\d+\.(\d+)/g), m => m[1].length)
            // );


            // handling error for division by zero
            const divisionMatches = [...eval.matchAll(/\/([0-9.]+)/g)];
            for (const match of divisionMatches) {
                const num = parseFloat(match[1]);
                if (num === 0) {
                    showError("division by zero");
                    return;
                }
            }

            // if (/\/0+(\.0*)?\b/.test(eval)) {
            //     showError(`<b>Invalid input:</b><br>Division by zero.`);
            //     return;
            // }

            // if (/\d+\/0/.test(eval)) {
            //     showError(`<b>Invalid input:</b><br>Division by zero.`);
            //     return;
            // }

            // test whether a string contains only: num, operators & decimal
            if (/^[0-9+\-*/.()]+$/.test(eval)) {
                // converting string to number coz toFixed works on number only
                let answer = roundOff(calculator(eval));
                // 8* or 3+ string like these returned NaN so handling those errors
                if (isNaN(answer) || answer == undefined) {
                    showError("Invalid input");
                    return;
                }
                if (!isFinite(answer)) {
                    showError("division by zero");
                    return;
                }
                history.push({ exp: eval, result: answer });
                updateHistory();
                // if result has decimal then fixed the num of digits after decimal we got in maxDecimalDigits variable
                // if(/^\d*\.\d+$/.test(answer)){
                //     input.value = answer.toFixed(maxDecimalDigits);
                // }else{
                //     input.value = answer.toFixed(0);
                // }
                input.value = answer;
            } else {
                // if we got anything other than num, operators & decimal then do these
                if (eval == "") {
                    return;
                } else {
                    showError(`<b>Invalid input:</b><br>Only numbers and + - * / operators are allowed.`);
                    return;
                }
            }
        });

        // adjust font-size when input has more characters
        function adjustFontSize() {
            const maxFont = 32;
            const medFont = 25;
            const minFont = 22;

            let length = input.value.length;
            let newFontSize;
            if (length >= 10 && length < 15) {
                newFontSize = medFont;
            } else if (length <= 10) {
                newFontSize = maxFont;
            } else if (length >= 15) {
                newFontSize = minFont;
            } else if (length <= 15 && length >= 10) {
                newFontSize = medFont;
            }
            input.style.fontSize = `${newFontSize}px`;
        }

        // error modal
        function showError(msg) {
            if (msg != "") {
                let modal = document.querySelector(".error");
                let msgHere = document.querySelector(".message");
                let close = document.querySelector(".close");

                modal.style.display = "flex";
                msgHere.innerHTML = msg;

                close.addEventListener("click", () => {
                    modal.style.display = "none";
                });
            }

        }

        // evaluation here
        function calculator(string) {

            // error handling
            if (!string || typeof string !== "string" || string == "") {
                showError("Please provide a non-empty string.");
                return;
            }


            // auto matching ( and ) to avoide getting wrong answers
            const openCount = (string.match(/\(/g) || []).length;
            const closeCount = (string.match(/\)/g) || []).length;
            if (openCount > closeCount) {
                string += ")".repeat(openCount - closeCount);
            }

            // converting sting into an array (decimal number accepted)

            // old logic doesn't support negative numbers and parenthesis ex: - ['4', '+', '5', '*', '6', '/', '2']
            // let infix = string.match(/\d+(\.\d+)?|\/|\*|\+|\-/g); 

            // new logic that supports negative number and parenthesis 
            let infix = tokenize(string); // ex: - ['(', '1', ')', '*', '(', '-2', ')']

            let postFix = []; // will contain numbers and higher precedence operators
            let opStack = []; // operator stack will have operators
            const precedence = { '+': 1, '-': 1, '*': 2, '/': 2 }; // to compare operators

            /*
            ->  now the plan is to separate numbers(postFix) and operators(opStack) from infix array
            ->  numbers will be pushed to postFix but if opStack has a operator of same precedence then that operator form opstack will be pop & pushed to postFix and the current operator will be pushed to opStack (ex:- if opStack has ["+", "*""] and current operator is "/" now both * & / have same precedence so * will be poped & pushed to postFix and / will we pushed to opStack).
            ->  also parenthesis are important to make sure order of operation matters and they will only become useless in final postfix where we don't add them
            */

            // ['(', '-2', ')', '*', '(', '-4', ')']
            // ['-2', '-4']

            // ['(', '-2', ')', '*', '(', '-4']
            // ['-2', '-4', '(']
            // the above process is done by the loop below
            for (let char of infix) {
                // if number
                if (/^-?\d+(\.\d+)?$/.test(char)) {
                    postFix.push(char);
                } else if (char === "(") {
                    opStack.push(char);
                } else if (char === ")") {
                    while (opStack.length && opStack[opStack.length - 1] !== "(") {
                        postFix.push(opStack.pop(char));
                    }
                    opStack.pop(); //remove the (
                } else if (/\+|\-|\*|\//.test(char)) {
                    // if operator
                    while (
                        opStack.length &&
                        precedence[opStack[opStack.length - 1]] >= precedence[char]
                    ) {
                        postFix.push(opStack.pop());
                    }
                    opStack.push(char);
                }
            }
            // post = [-2,-4]
            // opst = [*,(]

            /*
             after above loop we end up with two arrays
             postFix = ['4', '5', '6', '*', '2'] or ['1', '-2']
             opStack = ['+', '/']                or ['(', ')', '*', '(', ')']
            */

            // merging opStack with postFix
            //  ['+', '/'] ['4', '5', '6', '*', '2'] 
            let opLength = opStack.length;
            for (let i = 0; i < opLength; i++) {
                postFix.push(opStack.pop());
            }
            // now we have only one array postFix = ['4', '5', '6', '*', '2', '/', '+'] now we are gonna evaluate the array
            let result = [];
            for (let i = 0; i < postFix.length; i++) {

                /*
                looking for an operator in postFix if it's a number then it goes to else and pushed into result array 
                if it is an operator then we pop last two values from postFix array and evaluate it with the current found operator and this goes on and on till we are left with only one number and that would be our final result
                */
                // ['1', '-2', '*']
                if (["*", "/", "+", "-"].includes(postFix[i])) {
                    let last2Val = result.slice(-2); // 
                    if (result.length == 1) {
                        result[0] = Number(postFix[i] + result[0]);
                    } else {
                        result.splice(result.length - 2, 2);
                        let a = Number(last2Val[0]);
                        let b = Number(last2Val[1]);
                        const operator = postFix[i];
                        switch (operator) {
                            case "*":
                                result.push(a * b);
                                break;
                            case "/":
                                result.push(a / b);
                                break;
                            case "+":
                                result.push(a + b);
                                break;
                            case "-":
                                result.push(a - b);
                                break;
                        }
                    }

                } else {
                    result.push(postFix[i]);
                }
            }
            // console.log("final", result);
            return result[0];
        }

        // building the infix array
        function tokenize(exp) {
            let token = [];
            let num = "";

            for (let i = 0; i < exp.length; i++) {
                let char = exp[i];
                // first build decimal number (if any)
                if (/\d|\./.test(char)) {
                    num += char;
                } else {
                    /*
                    if we are in else that means current char is neither a number nor decimal it's an operator that mean previous number is built so it's time to push it to the token and empty the num
                    we are also checking if num is not empty to make sure num does have a number before pushing and empting it
                    */
                    if (num !== "") {
                        token.push(num);
                        num = ""; // empting to build another number
                    }
                    if (char === "-" && exp[i - 1] === "(") {
                        num = "-";
                    } else {
                        token.push(char);
                    }
                }
            }
            if (num !== "") token.push(num); // if num has anything left(like last number)then push it to token
            return token;
        }

        // history feature
        historyBtn.addEventListener("click", function () {
            this.classList.toggle("acitve");
            this.blur();
            console.log(history);
            if(history.length>0){
                document.querySelector(".empty-history").style.display = "none";
            }
            if (this.classList.contains("acitve")) {
                historyCon.style.transform = "translateX(-50%) scale(1)";
            } else {
                historyCon.style.transform = "translateX(-50%) scale(0)";
            }
        });

        // {"exp": "55+66","result": 121}
        function updateHistory() {
            let div = document.createElement("div");
            let p1 = document.createElement("p");
            let p2 = document.createElement("p");

            p1.setAttribute("class", "equ");
            p2.setAttribute("class", "equ-ans");

            p1.textContent = history[history.length - 1].exp.replace("/", "÷");
            p2.textContent = `=${history[history.length - 1].result}`;

            div.append(p1, p2);
            historyChild.append(div);
        }

        // smart round numbers
        function roundOff(num, precision = 10) {
            let number = Number(num);
            if (Number.isInteger(number)) return number; // already clean
            const rounded = parseFloat(number.toFixed(precision));
            return Math.abs(rounded - Math.round(rounded)) < 1e-9 ? Math.round(rounded) : rounded;
        }

        // info about the project
        infoBtn.addEventListener("click", function (e) {
            e.stopPropagation();
            e.target.classList.toggle("active");
            if (e.target.classList.contains("active")) {
                document.querySelector(".details").style.transform = "translate(-50%, -50%) scale(1)";
            } else {
                document.querySelector(".details").style.transform = "translate(-50%, -50%) scale(0)";
            }
        });
        document.body.addEventListener("click", function (e) {
            e.stopPropagation();
            if (infoBtn.classList.contains("active")) {
                infoBtn.classList.remove("active");
                document.querySelector(".details").style.transform = "translate(-50%, -50%) scale(0)";
            }
        });
        document.querySelector(".details").addEventListener("click", function (e) {
            e.stopPropagation();
            document.querySelector(".details").style.transform = "translate(-50%, -50%) scale(1)";
        });
    </script>
</body>

</html>